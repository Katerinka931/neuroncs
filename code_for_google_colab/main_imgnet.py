# -*- coding: utf-8 -*-
"""updated_model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1p2NM2yfkc7_7blxFCu6fuTPqPVOOMqVV
"""

import torch
import cv2
import glob
import os
import matplotlib.pyplot as plt
import torchvision
import albumentations as A
import numpy as np
from tqdm import tqdm
from enum import Enum

# CLASS CONSTS
# Device configuration
DEVICE = 'cuda' if torch.cuda.is_available() else 'cpu'

# Paths to your datasets
TRAIN_PATH = "data/train/*/*.jpg"
TEST_PATH = "data/test/*/*.jpg"
VALID_PATH = "data/valid/*/*.jpg"

# Batch size for data loaders
BATCH_SIZE = 128

# Data augmentation and preprocessing transformations
TRANSFORMS = A.Compose([
    A.HorizontalFlip(p=0.5),
    A.RandomBrightnessContrast(p=0.1),
    A.GaussNoise(p=0.1),
    A.Resize(224, 224),
    A.Normalize(),
])

# CLASS DATASET
class ImageDataset:

    def __init__(self, path, mode="train", transform=None):
        self.path = path
        self.transform = transform
        self.mode = mode
        self.imgs_path = glob.glob(self.path)

        if mode == "train":
            sub_folder_path = self.path.split("*")[0]
            self.all_folder_name = os.listdir(sub_folder_path)
            self.dict_name_no = {
                self.all_folder_name[i]: i for i in range(len(self.all_folder_name))
            }

    def __getitem__(self, index):
        img = cv2.imread(self.imgs_path[index])
        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

        if self.transform is not None:
            img = self.transform(image=img)["image"]

        img = torch.tensor(img, dtype=torch.float32).permute(2, 0, 1)

        if self.mode == "train":
            class_no = self.dict_name_no[self.imgs_path[index].split("\\")[-2]]
            class_vector = torch.zeros(len(self.dict_name_no))
            class_vector[class_no] = 1

            return img, class_vector

        return img

    def __len__(self):
        return len(self.imgs_path)

    def show(self, index):
        img = cv2.imread(self.imgs_path[index])
        class_name = self.imgs_path[index].split("/")[-2]  # Adjusted for Unix-style paths
        plt.imshow(img)
        plt.title(class_name)
        plt.show()

# CLASS RBF LAYSER
import torch
import torch.nn as nn

from typing import Callable

class RBFLayer(nn.Module):
    """
    Defines a Radial Basis Function Layer

    An RBF is defined by 5 elements:
        1. A radial kernel phi
        2. A positive shape parameter epsilon
        3. The number of kernels N, and their relative
           centers c_i, i=1, ..., N
        4. A norm ||.||
        5. A set of weights w_i, i=1, ..., N

    The output of an RBF is given by
    y(x) = sum_{i=1}^N a_i * phi(eps_i * ||x - c_i||)

    For more information check [1,2]

    [1] https://en.wikipedia.org/wiki/Radial_basis_function
    [2] https://en.wikipedia.org/wiki/Radial_basis_function_network
    """

    def __init__(
        self,
        in_features_dim: int,
        num_kernels: int,
        out_features_dim: int,
        radial_function: Callable[[torch.Tensor], torch.Tensor],
        norm_function: Callable[[torch.Tensor], torch.Tensor],
        normalization: bool = True,
        initial_shape_parameter: torch.Tensor = None,
        initial_centers_parameter: torch.Tensor = None,
        initial_weights_parameters: torch.Tensor = None,
        constant_shape_parameter: bool = False,
        constant_centers_parameter: bool = False,
        constant_weights_parameters: bool = False,
    ):
        super(RBFLayer, self).__init__()

        self.in_features_dim = in_features_dim
        self.num_kernels = num_kernels
        self.out_features_dim = out_features_dim
        self.radial_function = radial_function
        self.norm_function = norm_function
        self.normalization = normalization

        self.initial_shape_parameter = initial_shape_parameter
        self.constant_shape_parameter = constant_shape_parameter

        self.initial_centers_parameter = initial_centers_parameter
        self.constant_centers_parameter = constant_centers_parameter

        self.initial_weights_parameters = initial_weights_parameters
        self.constant_weights_parameters = constant_weights_parameters

        assert radial_function is not None and norm_function is not None
        assert normalization is False or normalization is True

        self._make_parameters()

    def _make_parameters(self) -> None:
        # Initialize linear combination weights
        if self.constant_weights_parameters:
            self.weights = nn.Parameter(
                self.initial_weights_parameters, requires_grad=False
            )
        else:
            self.weights = nn.Parameter(
                torch.zeros(
                    self.out_features_dim, self.num_kernels, dtype=torch.float32
                )
            )

        # Initialize kernels' centers
        if self.constant_centers_parameter:
            self.kernels_centers = nn.Parameter(
                self.initial_centers_parameter, requires_grad=False
            )
        else:
            self.kernels_centers = nn.Parameter(
                torch.zeros(self.num_kernels, self.in_features_dim, dtype=torch.float32)
            )

        # Initialize shape parameter
        if self.constant_shape_parameter:
            self.log_shapes = nn.Parameter(
                self.initial_shape_parameter, requires_grad=False
            )
        else:
            self.log_shapes = nn.Parameter(
                torch.zeros(self.num_kernels, dtype=torch.float32)
            )

        self.reset()

    def reset(
        self,
        upper_bound_kernels: float = 1.0,
        std_shapes: float = 0.1,
        gain_weights: float = 1.0,
    ) -> None:
        """
        Resets all the parameters.
        """
        if self.initial_centers_parameter is None:
            nn.init.uniform_(
                self.kernels_centers, a=-upper_bound_kernels, b=upper_bound_kernels
            )

        if self.initial_shape_parameter is None:
            nn.init.normal_(self.log_shapes, mean=0.0, std=std_shapes)

        if self.initial_weights_parameters is None:
            nn.init.xavier_uniform_(self.weights, gain=gain_weights)

    def forward(self, input: torch.Tensor) -> torch.Tensor:
        """
        Computes the output of the RBF layer given an input vector
        """
        # Input has size B x Fin
        batch_size = input.size(0)

        # Compute difference from centers
        # c has size B x num_kernels x Fin
        c = self.kernels_centers.expand(
            batch_size, self.num_kernels, self.in_features_dim
        )

        diff = input.view(batch_size, 1, self.in_features_dim) - c

        # Apply norm function; c has size B x num_kernels
        r = self.norm_function(diff)

        # Apply parameter, eps_r has size B x num_kernels
        eps_r = self.log_shapes.exp().expand(batch_size, self.num_kernels) * r

        # Normalize eps_r
        eps_r = (eps_r - eps_r.min(dim=-1)[0].unsqueeze(-1)) / (
            eps_r.max(dim=-1)[0].unsqueeze(-1) - eps_r.min(dim=-1)[0].unsqueeze(-1)
        )

        # Apply radial basis function; rbfs has size B x num_kernels
        rbfs = self.radial_function(eps_r)

        # Apply normalization
        if self.normalization:
            # 1e-9 prevents division by 0
            rbfs = rbfs / (1e-9 + rbfs.sum(dim=-1)).unsqueeze(-1)

        # Take linear combination
        out = self.weights.expand(
            batch_size, self.out_features_dim, self.num_kernels
        ) * rbfs.view(batch_size, 1, self.num_kernels)

        return out.sum(dim=-1)

    @property
    def get_kernels_centers(self):
        """Returns the centers of the kernels"""
        return self.kernels_centers.detach()

    @property
    def get_weights(self):
        """Returns the linear combination weights"""
        return self.weights.detach()

    @property
    def get_shapes(self):
        """Returns the shape parameters"""
        return self.log_shapes.detach().exp()

import torch

# Norm functions
def l_norm(x, p=2):
    return torch.norm(x, p=p, dim=-1)

# Radial basis functions
def rbf_gaussian(x):
    return torch.exp(-x.pow(2))

def rbf_linear(x):
    return x

def rbf_multiquadric(x):
    return torch.sqrt(1 + x.pow(2))

def rbf_inverse_quadratic(x):
    return 1 / (1 + x.pow(2))

def rbf_inverse_multiquadric(x):
    return 1 / torch.sqrt(1 + x.pow(2))

def train_model(model, epochs, train_dataloader, valid_dataloader, learning_rate):
    """
    Train the model and return accuracy and loss lists.
    """
    optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)
    criterion = torch.nn.CrossEntropyLoss()

    train_accuracy_list = []
    valid_accuracy_list = []
    train_loss_list = []
    valid_loss_list = []
    for epoch in range(epochs):
        model.train()
        train_losses = []
        valid_losses = []
        train_predictions = []
        valid_predictions = []
        train_labels = []
        valid_labels = []
        for images, labels in tqdm(train_dataloader):
            images = images.to(DEVICE)
            labels = labels.to(DEVICE)
            out = model(images)
            loss = criterion(out, torch.argmax(labels, dim=1))
            train_losses.append(loss.item())
            train_predictions.extend(torch.argmax(out, dim=1).cpu().numpy())
            train_labels.extend(torch.argmax(labels, dim=1).cpu().numpy())
            optimizer.zero_grad()
            loss.backward()
            optimizer.step()
        model.eval()
        with torch.no_grad():
            for images, labels in valid_dataloader:
                images = images.to(DEVICE)
                labels = labels.to(DEVICE)
                out = model(images)
                valid_predictions.extend(torch.argmax(out, dim=1).cpu().numpy())
                valid_labels.extend(torch.argmax(labels, dim=1).cpu().numpy())
                loss = criterion(out, torch.argmax(labels, dim=1))
                valid_losses.append(loss.item())

        train_accuracy = np.round(np.mean(np.array(train_predictions) == np.array(train_labels)), 3)
        valid_accuracy = np.round(np.mean(np.array(valid_predictions) == np.array(valid_labels)), 3)
        train_loss = np.round(np.mean(train_losses), 3)
        valid_loss = np.round(np.mean(valid_losses), 3)

        train_accuracy_list.append(train_accuracy)
        valid_accuracy_list.append(valid_accuracy)
        train_loss_list.append(train_loss)
        valid_loss_list.append(valid_loss)
        print(f"epoch {epoch + 1} loss_train: {train_loss} loss_valid: {valid_loss}, "
              f"accuracy : {np.round(valid_accuracy, 3)}")
    return train_accuracy_list, valid_accuracy_list, train_loss_list, valid_loss_list

def train_imagenet_with_RBF(learning_rate, epochs):
    print(TRAIN_PATH)
    print("RBF")
    train_dataset = ImageDataset(TRAIN_PATH, transform=TRANSFORMS)
    valid_dataset = ImageDataset(VALID_PATH, transform=TRANSFORMS, mode="train")

    train_dataloader = torch.utils.data.DataLoader(train_dataset, batch_size=BATCH_SIZE, shuffle=True)
    valid_dataloader = torch.utils.data.DataLoader(valid_dataset, batch_size=BATCH_SIZE, shuffle=True)

    # Use EfficientNet-B0
    model = torchvision.models.efficientnet_b0(weights=torchvision.models.EfficientNet_B0_Weights.IMAGENET1K_V1)
    # Replace classifier
    model.classifier[1] = RBFLayer(
        in_features_dim=1280,  # EfficientNet-B0's last layer has 1280 features
        num_kernels=150,
        out_features_dim=len(train_dataset.all_folder_name),
        radial_function=rbf_gaussian,
        norm_function=l_norm,
        normalization=True
    )
    model.to(DEVICE)

    train_accuracy, valid_accuracy, train_loss, valid_loss = train_model(
        model, epochs, train_dataloader, valid_dataloader, learning_rate
    )

    # Save the model if needed
    # torch.save(model.state_dict(), f'ready_models/model_efficientnet_b0_rbf_{epochs}.pth')

def train_imagenet_with_base_classifier(learning_rate, epochs):
    print(TRAIN_PATH)
    print("BASE CLASSIFIER")
    train_dataset = ImageDataset(TRAIN_PATH, transform=TRANSFORMS)
    valid_dataset = ImageDataset(VALID_PATH, transform=TRANSFORMS, mode="train")

    train_dataloader = torch.utils.data.DataLoader(train_dataset, batch_size=BATCH_SIZE, shuffle=True)
    valid_dataloader = torch.utils.data.DataLoader(valid_dataset, batch_size=BATCH_SIZE, shuffle=True)

    # Use EfficientNet-B0
    model = torchvision.models.efficientnet_b0(weights=torchvision.models.EfficientNet_B0_Weights.IMAGENET1K_V1)
    model.to(DEVICE)

    train_accuracy, valid_accuracy, train_loss, valid_loss = train_model(
        model, epochs, train_dataloader, valid_dataloader, learning_rate
    )

if __name__ == "__main__":
    # User inputs
    epochs = 100
    learning_rate = 1e-4  # Corrected learning rate notation

    train_imagenet_with_RBF(learning_rate, epochs)
    train_imagenet_with_base_classifier(learning_rate, epochs)
